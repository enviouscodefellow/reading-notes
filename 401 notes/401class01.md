## Code Fellows 401

### Day 01 Notes

[Home](../README.md)

#### Reading
[Pain and Suffering](https://codefellows.github.io/code-401-python-guide/curriculum/class-01/notes/pain_suffering)

[Beginners Guide to Big O](https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/)

#### Additional Resources
[Season 1, Episode 6, A friendly intro to Big O Notation](https://www.codenewbie.org/basecs/8)

#### Videos
[Names and Values in Python](https://www.youtube.com/watch?v=_AEJHKGk9ns)

#### Bookmark and Review
[Awesome Python Environment](https://towardsdatascience.com/how-to-setup-an-awesome-python-environment-for-data-science-or-anything-else-35d358cc95d5)

## Things I want to know more about

* Big O notation is a way to describe the performance of an algorithm in terms of how the number of inputs (n) affects the number of operations it performs.
* It is used to describe the upper bound of an algorithm's running time.
* The most common complexity classes are O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n) and O(n!).
* O(1) represents a constant time algorithm, which performs the same number of operations regardless of the input size.
* O(log n) represents a logarithmic time algorithm, which performs a number of operations proportional to the logarithm of the input size.
* O(n) represents a linear time algorithm, which performs a number of operations proportional to the input size.
* O(n log n) represents a log-linear time algorithm, which performs a number of operations proportional to the input size multiplied by the logarithm of the input size.
* O(n^2) represents a quadratic time algorithm, which performs a number of operations proportional to the input size squared.
* O(2^n) represents an exponential time algorithm, which performs a number of operations proportional to 2 raised to the power of the input size.
* O(n!) represents a factorial time algorithm, which performs a number of operations proportional to the factorial of the input size.